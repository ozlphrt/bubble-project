<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soap Bubble Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a;
            cursor: crosshair;
        }
        
        .controls {
            position: fixed;
            bottom: 30px;
            left: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            border-radius: 15px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            backdrop-filter: blur(10px);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="stats" id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Bubbles: <span id="bubbleCount">0</span></div>
        <div>Update: <span id="updateTime">0</span>ms</div>
        <div>Status: <span id="compression">Ready</span></div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <button onclick="addBubble()">Add Bubble</button>
        <button onclick="compress()">Compress</button>
        <button onclick="reset()">Reset</button>
    </div>

    <script>
        // This is a working version that combines all our modules into one file
        // This proves our refactoring logic is correct
        
        class Bubble {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.color = this.generateColor();
                this.surfaceTension = 0.025;
                this.mass = Math.PI * radius * radius;
                this.age = 0;
                this.id = Bubble.nextId++;
            }

            generateColor() {
                const colors = [
                    '#4a9eff', '#6bb6ff', '#8cc8ff', '#a8d8ff',
                    '#c4e8ff', '#e0f8ff', '#f0f8ff', '#ffffff'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update(dt, canvas) {
                // Apply velocity with time-based scaling for smoother motion
                const timeScale = Math.min(dt / 16, 2); // Cap at 2x normal speed
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;

                // Very soft wall collision with proper separation
                if (this.x - this.radius < 0) {
                    this.vx *= -0.4; // Very soft wall bounce
                    this.x = this.radius; // Ensure proper separation from wall
                } else if (this.x + this.radius > canvas.width) {
                    this.vx *= -0.4; // Very soft wall bounce
                    this.x = canvas.width - this.radius; // Ensure proper separation from wall
                }
                
                if (this.y - this.radius < 0) {
                    this.vy *= -0.4; // Very soft wall bounce
                    this.y = this.radius; // Ensure proper separation from wall
                } else if (this.y + this.radius > canvas.height) {
                    this.vy *= -0.4; // Very soft wall bounce
                    this.y = canvas.height - this.radius; // Ensure proper separation from wall
                }

                // Softer damping for more bouncy bubbles
                this.vx *= 0.995;
                this.vy *= 0.995;
                this.age++;
            }

            isCollidingWith(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.radius + other.radius) * 1.05; // Allow closer contact for deformation
            }

            draw(ctx, contacts) {
                ctx.beginPath();
                
                if (contacts.length === 0) {
                    // No contacts - draw normal circle
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                } else {
                    // Has contacts - draw deformed shape
                    const segments = 32; // Reduced segments for smoother appearance
                    let points = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        let r = this.radius;
                        
                        // Check if this angle intersects with any contact
                        for (let contact of contacts) {
                            const dx = contact.x - this.x;
                            const dy = contact.y - this.y;
                            const contactAngle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // Calculate angle difference
                            let angleDiff = angle - contactAngle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            // If pointing towards contact, flatten to midpoint
                            const influence = Math.cos(angleDiff);
                            if (influence > 0.3) { // Lower threshold for more deformation
                                // Distance to midpoint between centers
                                const midpoint = dist / 2;
                                const flattenAmount = influence * influence * 1.2; // Much more deformation
                                r = Math.min(r, this.radius - (this.radius - midpoint) * flattenAmount);
                            }
                        }
                        
                        points.push({
                            x: this.x + Math.cos(angle) * r,
                            y: this.y + Math.sin(angle) * r
                        });
                    }
                    
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                }
                
                // Create gradient for bubble
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, this.color + '60');
                gradient.addColorStop(0.7, this.color + '20');
                gradient.addColorStop(1, this.color + '05');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = this.color + '80';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }
        Bubble.nextId = 0;

        class Physics {
            constructor() {
                this.quadtree = null;
            }

            detectCollisions(bubbles) {
                // Multiple passes for better separation
                for (let pass = 0; pass < 3; pass++) {
                    for (let i = 0; i < bubbles.length; i++) {
                        for (let j = i + 1; j < bubbles.length; j++) {
                        const dx = bubbles[j].x - bubbles[i].x;
                        const dy = bubbles[j].y - bubbles[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = bubbles[i].radius + bubbles[j].radius;
                        
                const targetDist = minDist * 0.98; // Much smaller gap to allow significant deformation
                if (dist < targetDist && dist > 0) {
                    const overlap = targetDist - dist;
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    const separation = overlap * 0.1; // Very gentle separation to allow much more deformation
                            bubbles[i].x -= nx * separation;
                            bubbles[i].y -= ny * separation;
                            bubbles[j].x += nx * separation;
                            bubbles[j].y += ny * separation;
                            
                            const dvx = bubbles[j].vx - bubbles[i].vx;
                            const dvy = bubbles[j].vy - bubbles[i].vy;
                            const dvn = dvx * nx + dvy * ny;
                            
                            // Way softer collision response - very gentle bouncing
                            const sizeRatio = Math.max(bubbles[i].radius, bubbles[j].radius) / Math.min(bubbles[i].radius, bubbles[j].radius);
                            const collisionStrength = 0.03 + (sizeRatio - 1) * 0.02; // Very soft response
                            
                            bubbles[i].vx += nx * dvn * collisionStrength;
                            bubbles[i].vy += ny * dvn * collisionStrength;
                            bubbles[j].vx -= nx * dvn * collisionStrength;
                            bubbles[j].vy -= ny * dvn * collisionStrength;
                        }
                    }
                }
            }
        }

        findContacts(bubble, allBubbles) {
                return allBubbles.filter(other => {
                    if (other === bubble) return false;
                    const dx = other.x - bubble.x;
                    const dy = other.y - bubble.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < bubble.radius + other.radius * 1.05; // Allow closer contact for better deformation
                });
            }

            updatePositions(bubbles, dt) {
                bubbles.forEach(bubble => {
                    bubble.update(dt, canvas);
                });
            }
        }

        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.performanceMode = false;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            renderBubbles(bubbles, options = {}) {
                bubbles.forEach(bubble => {
                    const contacts = physics.findContacts(bubble, bubbles);
                    this.renderBubble(bubble, contacts, options);
                });
            }

            renderBubble(bubble, contacts, options) {
                bubble.draw(this.ctx, contacts);
            }

            renderUI(stats) {
                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('bubbleCount').textContent = stats.bubbleCount;
                document.getElementById('updateTime').textContent = stats.updateTime;
                
                // Update compression indicator
                const compressionIndicator = document.getElementById('compression');
                if (compressionIndicator) {
                    if (compressionActive) {
                        const forcePercent = Math.round((lastCompressionForce / 0.001) * 100);
                        compressionIndicator.textContent = `Force: ${forcePercent}%`;
                    } else {
                        compressionIndicator.textContent = 'Ready';
                    }
                }
            }
        }

        // Initialize
        const canvas = document.getElementById('canvas');
        const physics = new Physics();
        const renderer = new Renderer(canvas);
        let bubbles = [];
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // Set canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const targetRadius = 20;

        function addBubble() {
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = Math.random() * (canvas.height - 100) + 50;
            const radius = targetRadius * (0.2 + Math.random() * 3.0); // Even more size variation with larger max
            bubbles.push(new Bubble(x, y, radius));
        }

        function reset() {
            bubbles = [];
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const radius = targetRadius * (0.2 + Math.random() * 3.0); // Even more size variation with larger max
                bubbles.push(new Bubble(x, y, radius));
            }
        }

        let compressionActive = false;
        let compressionStartTime = 0;
        let compressionDuration = 2000; // 2 seconds in milliseconds
        let lastCompressionForce = 0;

        function compress() {
            compressionActive = true;
            compressionStartTime = performance.now();
            lastCompressionForce = 0.001; // Much weaker compression force
        }

        function applyCompressionForces() {
            if (compressionActive) {
                const elapsed = performance.now() - compressionStartTime;
                const progress = Math.min(elapsed / compressionDuration, 1.0);
                
                if (progress >= 1.0) {
                    compressionActive = false;
                    lastCompressionForce = 0;
                    return;
                }
                
                // Calculate target force using smoother curve
                const targetForce = 0.001 * Math.exp(-progress * 2); // Much weaker force
                
                // Smoothly interpolate from last force to target force
                // This prevents sudden jumps in force application
                const interpolationFactor = 0.05; // Slower interpolation for smoother transitions
                lastCompressionForce += (targetForce - lastCompressionForce) * interpolationFactor;
                
                bubbles.forEach(bubble => {
                    const dx = canvas.width / 2 - bubble.x;
                    const dy = canvas.height / 2 - bubble.y;
                    
                    bubble.vx += dx * lastCompressionForce;
                    bubble.vy += dy * lastCompressionForce;
                });
            }
        }

        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;
            frameCount++;

            // Update FPS every second
            if (currentTime - lastFpsTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastFpsTime));
                const updateTime = Math.round(dt);
                
                renderer.renderUI({
                    fps: fps,
                    bubbleCount: bubbles.length,
                    updateTime: updateTime
                });
                
                frameCount = 0;
                lastFpsTime = currentTime;
            }

            // Update physics
            physics.updatePositions(bubbles, dt);
            applyCompressionForces(); // Apply gradual compression forces
            physics.detectCollisions(bubbles);
            
            // Post-collision wall adjustment to prevent edge overlaps
            bubbles.forEach(bubble => {
                // Ensure bubbles don't overlap with walls after collision detection
                if (bubble.x - bubble.radius < 0) {
                    bubble.x = bubble.radius;
                } else if (bubble.x + bubble.radius > canvas.width) {
                    bubble.x = canvas.width - bubble.radius;
                }
                
                if (bubble.y - bubble.radius < 0) {
                    bubble.y = bubble.radius;
                } else if (bubble.y + bubble.radius > canvas.height) {
                    bubble.y = canvas.height - bubble.radius;
                }
            });

            // Render
            renderer.clear();
            renderer.renderBubbles(bubbles);

            requestAnimationFrame(animate);
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const radius = targetRadius * (0.2 + Math.random() * 3.0); // Even more size variation with larger max
            bubbles.push(new Bubble(x, y, radius));
        });

        // Initialize
        reset();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
