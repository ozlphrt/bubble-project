<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soap Bubble Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a;
            cursor: crosshair;
        }
        
        .controls {
            position: fixed;
            bottom: 30px;
            left: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            border-radius: 15px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            backdrop-filter: blur(10px);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stats {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="stats" id="stats">
        <div>FPS: <span id="fps">0</span></div>
        <div>Bubbles: <span id="bubbleCount">0</span></div>
        <div>Update: <span id="updateTime">0</span>ms</div>
        <div>Status: <span id="compression">Ready</span></div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <button onclick="addBubble()">Add Bubble</button>
        <button onclick="compress()">Compress</button>
        <button onclick="reset()">Reset</button>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
            <label style="display: block; margin-bottom: 8px; font-size: 12px; opacity: 0.8;">Coalescence Rate</label>
            <input type="range" id="coalescenceSlider" min="0" max="0.1" step="0.001" value="0.01" 
                   style="width: 100%; cursor: pointer;"
                   oninput="updateCoalescenceRate(this.value)">
            <div style="font-size: 11px; opacity: 0.6; margin-top: 4px;">
                <span id="coalescenceValue">0.01</span>
            </div>
        </div>
    </div>

    <script>
        // This is a working version that combines all our modules into one file
        // This proves our refactoring logic is correct
        
        class Bubble {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.color = this.generateColor();
                this.surfaceTension = 0.025;
                this.mass = Math.PI * radius * radius;
                this.age = 0;
                this.id = Bubble.nextId++;
                this.contactDurations = new Map(); // Track contact time with other bubbles
                this.merging = false; // Flag for merge animation
                this.mergeProgress = 0; // 0 to 1 during merge
                this.mergingWith = null; // Reference to merge target
            }

            generateColor() {
                const colors = [
                    '#4a9eff', '#6bb6ff', '#8cc8ff', '#a8d8ff',
                    '#c4e8ff', '#e0f8ff', '#f0f8ff', '#ffffff'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update(dt, canvas) {
                // Apply velocity with time-based scaling for smoother motion
                const timeScale = Math.min(dt / 16, 2); // Cap at 2x normal speed
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;

                // Very soft wall collision with proper separation
                if (this.x - this.radius < 0) {
                    this.vx *= -0.4; // Very soft wall bounce
                    this.x = this.radius; // Ensure proper separation from wall
                } else if (this.x + this.radius > canvas.width) {
                    this.vx *= -0.4; // Very soft wall bounce
                    this.x = canvas.width - this.radius; // Ensure proper separation from wall
                }
                
                if (this.y - this.radius < 0) {
                    this.vy *= -0.4; // Very soft wall bounce
                    this.y = this.radius; // Ensure proper separation from wall
                } else if (this.y + this.radius > canvas.height) {
                    this.vy *= -0.4; // Very soft wall bounce
                    this.y = canvas.height - this.radius; // Ensure proper separation from wall
                }

                // Softer damping for more bouncy bubbles
                this.vx *= 0.995;
                this.vy *= 0.995;
                this.age++;
            }

            isCollidingWith(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.radius + other.radius) * 1.05; // Allow closer contact for deformation
            }

            draw(ctx, contacts) {
                ctx.beginPath();
                
                if (contacts.length === 0) {
                    // No contacts - draw normal circle
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                } else {
                    // Has contacts - draw deformed shape
                    const segments = 32; // Reduced segments for smoother appearance
                    let points = [];
                    
                    for (let i = 0; i < segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        let r = this.radius;
                        
                        // Check if this angle intersects with any contact
                        for (let contact of contacts) {
                            const dx = contact.x - this.x;
                            const dy = contact.y - this.y;
                            const contactAngle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // Calculate angle difference
                            let angleDiff = angle - contactAngle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            // If pointing towards contact, flatten to midpoint
                            const influence = Math.cos(angleDiff);
                            if (influence > 0.3) { // Lower threshold for more deformation
                                // Distance to midpoint between centers
                                const midpoint = dist / 2;
                                const flattenAmount = influence * influence * 1.2; // Much more deformation
                                r = Math.min(r, this.radius - (this.radius - midpoint) * flattenAmount);
                            }
                        }
                        
                        points.push({
                            x: this.x + Math.cos(angle) * r,
                            y: this.y + Math.sin(angle) * r
                        });
                    }
                    
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                }
                
                // Create gradient for bubble
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, this.color + '60');
                gradient.addColorStop(0.7, this.color + '20');
                gradient.addColorStop(1, this.color + '05');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = this.color + '80';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }
        Bubble.nextId = 0;

        class Physics {
            constructor() {
                this.quadtree = null;
                this.coalescenceRate = 0.01; // Probability per frame
                this.contactDurationThreshold = 30; // Frames before merge can occur
            }

            detectCollisions(bubbles) {
                // Multiple passes for better separation
                for (let pass = 0; pass < 3; pass++) {
                    for (let i = 0; i < bubbles.length; i++) {
                        for (let j = i + 1; j < bubbles.length; j++) {
                        const dx = bubbles[j].x - bubbles[i].x;
                        const dy = bubbles[j].y - bubbles[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = bubbles[i].radius + bubbles[j].radius;
                        
                const targetDist = minDist * 0.98; // Much smaller gap to allow significant deformation
                if (dist < targetDist && dist > 0) {
                    const overlap = targetDist - dist;
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    const separation = overlap * 0.1; // Very gentle separation to allow much more deformation
                            bubbles[i].x -= nx * separation;
                            bubbles[i].y -= ny * separation;
                            bubbles[j].x += nx * separation;
                            bubbles[j].y += ny * separation;
                            
                            const dvx = bubbles[j].vx - bubbles[i].vx;
                            const dvy = bubbles[j].vy - bubbles[i].vy;
                            const dvn = dvx * nx + dvy * ny;
                            
                            // Way softer collision response - very gentle bouncing
                            const sizeRatio = Math.max(bubbles[i].radius, bubbles[j].radius) / Math.min(bubbles[i].radius, bubbles[j].radius);
                            const collisionStrength = 0.03 + (sizeRatio - 1) * 0.02; // Very soft response
                            
                            bubbles[i].vx += nx * dvn * collisionStrength;
                            bubbles[i].vy += ny * dvn * collisionStrength;
                            bubbles[j].vx -= nx * dvn * collisionStrength;
                            bubbles[j].vy -= ny * dvn * collisionStrength;
                        }
                    }
                }
            }
        }

        findContacts(bubble, allBubbles) {
                return allBubbles.filter(other => {
                    if (other === bubble) return false;
                    const dx = other.x - bubble.x;
                    const dy = other.y - bubble.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < bubble.radius + other.radius * 1.05; // Allow closer contact for better deformation
                });
            }

            shouldCoalesce(b1, b2) {
                // Don't merge if either is already merging
                if (b1.merging || b2.merging) return false;
                
                // Check contact duration
                const contactDuration = b1.contactDurations.get(b2.id) || 0;
                if (contactDuration < this.contactDurationThreshold) return false;
                
                // Calculate pressure differential (using surface tension / radius)
                const p1 = b1.surfaceTension / b1.radius;
                const p2 = b2.surfaceTension / b2.radius;
                const pressureDiff = Math.abs(p1 - p2);
                const pressureFactor = pressureDiff / Math.min(p1, p2);
                
                // Stochastic rupture - higher pressure difference = higher probability
                const ruptureProbability = this.coalescenceRate * (1 + pressureFactor);
                
                return Math.random() < ruptureProbability;
            }

            mergeBubbles(b1, b2) {
                // Volume conservation (area in 2D)
                const area1 = Math.PI * b1.radius * b1.radius;
                const area2 = Math.PI * b2.radius * b2.radius;
                const totalArea = area1 + area2;
                const newRadius = Math.sqrt(totalArea / Math.PI);
                
                // Weighted center of mass
                const mass1 = area1;
                const mass2 = area2;
                const totalMass = mass1 + mass2;
                const newX = (b1.x * mass1 + b2.x * mass2) / totalMass;
                const newY = (b1.y * mass1 + b2.y * mass2) / totalMass;
                
                // Momentum conservation
                const newVx = (b1.vx * mass1 + b2.vx * mass2) / totalMass;
                const newVy = (b1.vy * mass1 + b2.vy * mass2) / totalMass;
                
                // Create new merged bubble
                const merged = new Bubble(newX, newY, newRadius);
                merged.vx = newVx;
                merged.vy = newVy;
                
                // Blend colors (take the color of the larger bubble)
                merged.color = b1.radius > b2.radius ? b1.color : b2.color;
                
                return merged;
            }

            updateContactDurations(bubbles) {
                // Update contact durations for all bubbles
                bubbles.forEach(bubble => {
                    const currentContacts = new Set();
                    
                    // Find all current contacts
                    bubbles.forEach(other => {
                        if (other === bubble || other.merging) return;
                        
                        const dx = other.x - bubble.x;
                        const dy = other.y - bubble.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < bubble.radius + other.radius) {
                            currentContacts.add(other.id);
                            const duration = bubble.contactDurations.get(other.id) || 0;
                            bubble.contactDurations.set(other.id, duration + 1);
                        }
                    });
                    
                    // Remove old contacts no longer touching
                    for (let [id, duration] of bubble.contactDurations.entries()) {
                        if (!currentContacts.has(id)) {
                            bubble.contactDurations.delete(id);
                        }
                    }
                });
            }

            detectCoalescence(bubbles) {
                const toMerge = [];
                
                for (let i = 0; i < bubbles.length; i++) {
                    for (let j = i + 1; j < bubbles.length; j++) {
                        if (bubbles[i].merging || bubbles[j].merging) continue;
                        
                        if (this.shouldCoalesce(bubbles[i], bubbles[j])) {
                            toMerge.push([bubbles[i], bubbles[j]]);
                        }
                    }
                }
                
                return toMerge;
            }

            updatePositions(bubbles, dt) {
                bubbles.forEach(bubble => {
                    bubble.update(dt, canvas);
                });
            }
        }

        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.performanceMode = false;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            renderBubbles(bubbles, options = {}) {
                bubbles.forEach(bubble => {
                    const contacts = physics.findContacts(bubble, bubbles);
                    this.renderBubble(bubble, contacts, options);
                });
            }

            renderBubble(bubble, contacts, options) {
                // Apply merge animation if bubble is merging
                if (bubble.merging && bubble.mergingWith) {
                    this.ctx.save();
                    
                    // Fade out during merge
                    this.ctx.globalAlpha = 1.0 - bubble.mergeProgress;
                    
                    // Shrink slightly during merge
                    const scale = 1.0 - bubble.mergeProgress * 0.3;
                    this.ctx.translate(bubble.x, bubble.y);
                    this.ctx.scale(scale, scale);
                    this.ctx.translate(-bubble.x, -bubble.y);
                    
                    bubble.draw(this.ctx, contacts);
                    this.ctx.restore();
                    
                    // Draw merge effect (particle-like shimmer)
                    if (bubble.mergeProgress > 0.2) {
                        this.drawMergeEffect(bubble, bubble.mergingWith, bubble.mergeProgress);
                    }
                } else {
                    bubble.draw(this.ctx, contacts);
                }
            }

            drawMergeEffect(b1, b2, progress) {
                const ctx = this.ctx;
                const midX = (b1.x + b2.x) / 2;
                const midY = (b1.y + b2.y) / 2;
                
                // Draw shimmering particles moving to center
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const dist = (1.0 - progress) * Math.max(b1.radius, b2.radius);
                    const x = midX + Math.cos(angle) * dist;
                    const y = midY + Math.sin(angle) * dist;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2 + progress * 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * (1.0 - progress)})`;
                    ctx.fill();
                }
            }

            renderUI(stats) {
                document.getElementById('fps').textContent = stats.fps;
                document.getElementById('bubbleCount').textContent = stats.bubbleCount;
                document.getElementById('updateTime').textContent = stats.updateTime;
                
                // Update compression indicator
                const compressionIndicator = document.getElementById('compression');
                if (compressionIndicator) {
                    if (compressionActive) {
                        const forcePercent = Math.round((lastCompressionForce / 0.001) * 100);
                        compressionIndicator.textContent = `Force: ${forcePercent}%`;
                    } else {
                        compressionIndicator.textContent = 'Ready';
                    }
                }
            }
        }

        // Initialize
        const canvas = document.getElementById('canvas');
        const physics = new Physics();
        const renderer = new Renderer(canvas);
        let bubbles = [];
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // Set canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const targetRadius = 20;

        function addBubble() {
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = Math.random() * (canvas.height - 100) + 50;
            const radius = targetRadius * (0.2 + Math.random() * 3.0); // Even more size variation with larger max
            bubbles.push(new Bubble(x, y, radius));
        }

        function reset() {
            bubbles = [];
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const radius = targetRadius * (0.2 + Math.random() * 3.0); // Even more size variation with larger max
                bubbles.push(new Bubble(x, y, radius));
            }
        }

        let compressionActive = false;
        let compressionStartTime = 0;
        let compressionDuration = 2000; // 2 seconds in milliseconds
        let lastCompressionForce = 0;

        function compress() {
            compressionActive = true;
            compressionStartTime = performance.now();
            lastCompressionForce = 0.001; // Much weaker compression force
        }

        function applyCompressionForces() {
            if (compressionActive) {
                const elapsed = performance.now() - compressionStartTime;
                const progress = Math.min(elapsed / compressionDuration, 1.0);
                
                if (progress >= 1.0) {
                    compressionActive = false;
                    lastCompressionForce = 0;
                    return;
                }
                
                // Calculate target force using smoother curve
                const targetForce = 0.001 * Math.exp(-progress * 2); // Much weaker force
                
                // Smoothly interpolate from last force to target force
                // This prevents sudden jumps in force application
                const interpolationFactor = 0.05; // Slower interpolation for smoother transitions
                lastCompressionForce += (targetForce - lastCompressionForce) * interpolationFactor;
                
                bubbles.forEach(bubble => {
                    const dx = canvas.width / 2 - bubble.x;
                    const dy = canvas.height / 2 - bubble.y;
                    
                    bubble.vx += dx * lastCompressionForce;
                    bubble.vy += dy * lastCompressionForce;
                });
            }
        }

        function updateCoalescenceRate(value) {
            physics.coalescenceRate = parseFloat(value);
            document.getElementById('coalescenceValue').textContent = parseFloat(value).toFixed(3);
        }

        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;
            frameCount++;

            // Update FPS every second
            if (currentTime - lastFpsTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastFpsTime));
                const updateTime = Math.round(dt);
                
                renderer.renderUI({
                    fps: fps,
                    bubbleCount: bubbles.length,
                    updateTime: updateTime
                });
                
                frameCount = 0;
                lastFpsTime = currentTime;
            }

            // Update physics
            physics.updatePositions(bubbles, dt);
            applyCompressionForces(); // Apply gradual compression forces
            physics.detectCollisions(bubbles);
            
            // Update contact durations for coalescence tracking
            physics.updateContactDurations(bubbles);
            
            // Detect and handle coalescence
            const mergePairs = physics.detectCoalescence(bubbles);
            const mergeAnimationDuration = 30; // frames
            
            if (mergePairs.length > 0) {
                mergePairs.forEach(([b1, b2]) => {
                    // Mark bubbles as merging
                    b1.merging = true;
                    b2.merging = true;
                    b1.mergingWith = b2;
                    b2.mergingWith = b1;
                    b1.mergeProgress = 0;
                    b2.mergeProgress = 0;
                });
            }
            
            // Update merge animations and perform actual merge
            bubbles = bubbles.filter(bubble => {
                if (bubble.merging) {
                    bubble.mergeProgress += 1.0 / mergeAnimationDuration;
                    
                    // Complete merge at end of animation
                    if (bubble.mergeProgress >= 1.0 && bubble.mergingWith) {
                        // Only merge once (the first bubble in the pair)
                        if (bubble.id < bubble.mergingWith.id && bubbles.includes(bubble.mergingWith)) {
                            const merged = physics.mergeBubbles(bubble, bubble.mergingWith);
                            bubbles.push(merged);
                        }
                        return false; // Remove this bubble
                    }
                }
                return true; // Keep bubble
            });
            
            // Post-collision wall adjustment to prevent edge overlaps
            bubbles.forEach(bubble => {
                // Ensure bubbles don't overlap with walls after collision detection
                if (bubble.x - bubble.radius < 0) {
                    bubble.x = bubble.radius;
                } else if (bubble.x + bubble.radius > canvas.width) {
                    bubble.x = canvas.width - bubble.radius;
                }
                
                if (bubble.y - bubble.radius < 0) {
                    bubble.y = bubble.radius;
                } else if (bubble.y + bubble.radius > canvas.height) {
                    bubble.y = canvas.height - bubble.radius;
                }
            });

            // Render
            renderer.clear();
            renderer.renderBubbles(bubbles);

            requestAnimationFrame(animate);
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const radius = targetRadius * (0.2 + Math.random() * 3.0); // Even more size variation with larger max
            bubbles.push(new Bubble(x, y, radius));
        });

        // Initialize
        reset();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
